

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>alphatims.bruker &mdash; alphatims  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> alphatims
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../alphatims.utils.html">alphatims.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../alphatims.bruker.html">alphatims.bruker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../alphatims.plotting.html">alphatims.plotting</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">alphatims</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>alphatims.bruker</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for alphatims.bruker</h1><div class="highlight"><pre>
<span></span><span class="ch">#!python</span>
<span class="sd">&quot;&quot;&quot;This module provides functions to handle Bruker data.</span>
<span class="sd">It primarily implements the TimsTOF class, that acts as an in-memory container</span>
<span class="sd">for Bruker data accession and storage.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># builtin</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="c1"># external</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="c1"># local</span>
<span class="kn">import</span> <span class="nn">alphatims</span>
<span class="kn">import</span> <span class="nn">alphatims.utils</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span><span class="p">:</span>
    <span class="n">BRUKER_DLL_FILE_NAME</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">EXT_PATH</span><span class="p">,</span>
        <span class="s2">&quot;timsdata.dll&quot;</span>
    <span class="p">)</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;linux&quot;</span><span class="p">:</span>
    <span class="n">BRUKER_DLL_FILE_NAME</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">EXT_PATH</span><span class="p">,</span>
        <span class="s2">&quot;timsdata.so&quot;</span>
    <span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
        <span class="s2">&quot;WARNING: &quot;</span>
        <span class="s2">&quot;No Bruker libraries are available for this operating system. &quot;</span>
        <span class="s2">&quot;Intensities are uncalibrated, resulting in (very) small differences. &quot;</span>
        <span class="s2">&quot;However, mobility and m/z values need to be estimated. &quot;</span>
        <span class="s2">&quot;While this estimation often returns acceptable results with errors &quot;</span>
        <span class="s2">&quot;&lt; 0.02 Th, huge errors (e.g. offsets of 6 Th) have already been &quot;</span>
        <span class="s2">&quot;observed for some samples!&quot;</span>
    <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">BRUKER_DLL_FILE_NAME</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>


<div class="viewcode-block" id="init_bruker_dll"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.init_bruker_dll">[docs]</a><span class="k">def</span> <span class="nf">init_bruker_dll</span><span class="p">(</span><span class="n">bruker_dll_file_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">BRUKER_DLL_FILE_NAME</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Open a bruker.dll in Python.</span>

<span class="sd">    Five functions are defined for this dll:</span>

<span class="sd">        - tims_open: [c_char_p, c_uint32] -&gt; c_uint64</span>
<span class="sd">        - tims_close: [c_char_p, c_uint32] -&gt; c_uint64</span>
<span class="sd">        - tims_read_scans_v2: [c_uint64, c_int64, c_uint32, c_uint32, c_void_p, c_uint32] -&gt; c_uint32</span>
<span class="sd">        - tims_index_to_mz: [c_uint64, c_int64, POINTER(c_double), POINTER(c_double), c_uint32] -&gt; None</span>
<span class="sd">        - tims_scannum_to_oneoverk0: Same as &quot;tims_index_to_mz&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bruker_dll_file_name : str</span>
<span class="sd">        The absolute path to the timsdata.dll.</span>
<span class="sd">        Default is alphatims.utils.BRUKER_DLL_FILE_NAME.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : ctypes.cdll</span>
<span class="sd">        The Bruker dll library.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">ctypes</span>
    <span class="n">bruker_dll</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">bruker_dll_file_name</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_open</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">]</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_open</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_close</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">]</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_close</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_read_scans_v2</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int64</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span>
    <span class="p">]</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_read_scans_v2</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_index_to_mz</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int64</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span>
    <span class="p">]</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_index_to_mz</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_scannum_to_oneoverk0</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int64</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">),</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span>
    <span class="p">]</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_scannum_to_oneoverk0</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint32</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_set_num_threads</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint64</span><span class="p">]</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_set_num_threads</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_set_num_threads</span><span class="p">(</span><span class="n">alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">MAX_THREADS</span><span class="p">)</span>
    <span class="c1"># multiple threads is equally fast as just 1 for io?</span>
    <span class="c1"># bruker_dll.tims_set_num_threads(1)</span>
    <span class="k">return</span> <span class="n">bruker_dll</span></div>


<div class="viewcode-block" id="open_bruker_d_folder"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.open_bruker_d_folder">[docs]</a><span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">open_bruker_d_folder</span><span class="p">(</span>
    <span class="n">bruker_d_folder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">bruker_dll_file_name</span><span class="o">=</span><span class="n">BRUKER_DLL_FILE_NAME</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A context manager for a bruker dll connection to a .d folder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bruker_d_folder_name : str</span>
<span class="sd">        The name of a Bruker .d folder.</span>
<span class="sd">    bruker_dll_file_name : str, ctypes.cdll</span>
<span class="sd">        The path to Bruker&#39; timsdata.dll library.</span>
<span class="sd">        Alternatively, the library itself can be passed as argument.</span>
<span class="sd">        Default is alphatims.utils.BRUKER_DLL_FILE_NAME,</span>
<span class="sd">        which in itself is dependent on the OS.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : tuple (ctypes.cdll, int).</span>
<span class="sd">        The opened bruker dll and identifier of the .d folder.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bruker_dll_file_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">bruker_dll</span> <span class="o">=</span> <span class="n">init_bruker_dll</span><span class="p">(</span><span class="n">bruker_dll_file_name</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Opening handle for </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">bruker_d_folder_handle</span> <span class="o">=</span> <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_open</span><span class="p">(</span>
            <span class="n">bruker_d_folder_name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span>
            <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">yield</span> <span class="n">bruker_dll</span><span class="p">,</span> <span class="n">bruker_d_folder_handle</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Closing handle for </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_close</span><span class="p">(</span><span class="n">bruker_d_folder_handle</span><span class="p">)</span></div>


<div class="viewcode-block" id="read_bruker_sql"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.read_bruker_sql">[docs]</a><span class="k">def</span> <span class="nf">read_bruker_sql</span><span class="p">(</span>
    <span class="n">bruker_d_folder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">add_zeroth_frame</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">drop_polarity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Read metadata and (fragment) frames from a Bruker .d folder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bruker_d_folder_name : str</span>
<span class="sd">        The name of a Bruker .d folder.</span>
<span class="sd">    add_zeroth_frame : bool</span>
<span class="sd">        Bruker uses 1-indexing for frames.</span>
<span class="sd">        If True, a zeroth frame is added without any TOF detections to</span>
<span class="sd">        make Python simulate this 1-indexing.</span>
<span class="sd">        If False, frames are 0-indexed.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    drop_polarity : bool</span>
<span class="sd">        The polarity column of the frames table contains &quot;+&quot; or &quot;-&quot; and</span>
<span class="sd">        is not numerical.</span>
<span class="sd">        If True, the polarity column is dropped from the frames table.</span>
<span class="sd">        this ensures a fully numerical pd.DataFrame.</span>
<span class="sd">        If False, this column is kept, resulting in a pd.DataFrame with</span>
<span class="sd">        dtype=object.</span>
<span class="sd">        Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : tuple</span>
<span class="sd">        (str, dict, pd.DataFrame, pd.DataFrame).</span>
<span class="sd">        The acquisition_mode, global_meta_data, frames and fragment_frames.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When table &quot;MsMsType&quot; is not 8 or 9.</span>
<span class="sd">        In this case it is unclear if it is ddaPASEF or diaPASEF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sqlite3</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading frame metadata for </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bruker_d_folder_name</span><span class="p">,</span> <span class="s2">&quot;analysis.tdf&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="k">as</span> <span class="n">sql_database_connection</span><span class="p">:</span>
        <span class="n">global_meta_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span>
            <span class="s2">&quot;SELECT * from GlobalMetaData&quot;</span><span class="p">,</span>
            <span class="n">sql_database_connection</span>
        <span class="p">)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span>
            <span class="s2">&quot;SELECT * FROM Frames&quot;</span><span class="p">,</span>
            <span class="n">sql_database_connection</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="mi">9</span> <span class="ow">in</span> <span class="n">frames</span><span class="o">.</span><span class="n">MsMsType</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="n">acquisition_mode</span> <span class="o">=</span> <span class="s2">&quot;diaPASEF&quot;</span>
            <span class="n">fragment_frames</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span>
                <span class="s2">&quot;SELECT * FROM DiaFrameMsMsInfo&quot;</span><span class="p">,</span>
                <span class="n">sql_database_connection</span>
            <span class="p">)</span>
            <span class="n">fragment_frame_groups</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span>
                <span class="s2">&quot;SELECT * from DiaFrameMsMsWindows&quot;</span><span class="p">,</span>
                <span class="n">sql_database_connection</span>
            <span class="p">)</span>
            <span class="n">fragment_frames</span> <span class="o">=</span> <span class="n">fragment_frames</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="n">fragment_frame_groups</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>
            <span class="n">fragment_frames</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;WindowGroup&quot;</span><span class="p">:</span> <span class="s2">&quot;Precursor&quot;</span><span class="p">},</span>
                <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="mi">8</span> <span class="ow">in</span> <span class="n">frames</span><span class="o">.</span><span class="n">MsMsType</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="n">acquisition_mode</span> <span class="o">=</span> <span class="s2">&quot;PASEF&quot;</span>
            <span class="n">fragment_frames</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span>
                <span class="s2">&quot;SELECT * from PasefFrameMsMsInfo&quot;</span><span class="p">,</span>
                <span class="n">sql_database_connection</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Scan mode is not PASEF or diaPASEF&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_zeroth_frame</span><span class="p">:</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                    <span class="n">frames</span><span class="p">,</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">Id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">Time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">MaxIntensity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">SummedIntensities</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">NumPeaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">fragment_frames</span><span class="o">.</span><span class="n">Frame</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">col</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_numeric</span><span class="p">(</span>
                    <span class="n">frames</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">frames</span> <span class="k">if</span> <span class="n">col</span> <span class="o">!=</span> <span class="s2">&quot;Polarity&quot;</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">acquisition_mode</span><span class="p">,</span>
            <span class="n">global_meta_data</span><span class="p">,</span>
            <span class="n">frames</span><span class="p">,</span>
            <span class="n">fragment_frames</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="parse_decompressed_bruker_binary"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.parse_decompressed_bruker_binary">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nogil</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">parse_decompressed_bruker_binary</span><span class="p">(</span><span class="n">decomp_data</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Parse a Bruker binary frame buffer into scans, tofs and intensities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    decomp_data : bytes</span>
<span class="sd">        A Bruker frame binary buffer that is already decompressed with pyzstd.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : tuple (np.uint32[:], np.uint32[:], np.uint32[:]).</span>
<span class="sd">        The scan_indices, tof_indices and intensities present in this binary</span>
<span class="sd">        array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">decomp_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">scan_count</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scan_indices</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[:</span><span class="n">scan_count</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">scan_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tof_indices</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">scan_count</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">scan_indices</span><span class="p">:</span>
        <span class="n">current_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">current_sum</span> <span class="o">+=</span> <span class="n">tof_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">tof_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_sum</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">intensities</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">scan_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">last_scan</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensities</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scan_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">scan_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">scan_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_scan</span>
    <span class="k">return</span> <span class="n">scan_indices</span><span class="p">,</span> <span class="n">tof_indices</span><span class="p">,</span> <span class="n">intensities</span></div>


<div class="viewcode-block" id="process_frame"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.process_frame">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">threadpool</span><span class="p">(</span><span class="n">progress_callback</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">process_frame</span><span class="p">(</span>
    <span class="n">frame_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">tdf_bin_file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">tims_offset_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">scan_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">intensities</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tof_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">frame_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">max_scan_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Read and parse a frame directly from a Bruker .d.analysis.tdf_bin.</span>

<span class="sd">    IMPORTANT NOTE: This function is decorated with alphatims.utils.threadpool.</span>
<span class="sd">    The first argument is thus expected to be provided as an iterable</span>
<span class="sd">    containing ints instead of a single int.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame_id : int</span>
<span class="sd">        The frame number that should be processed.</span>
<span class="sd">        Note that this is interpreted as 1-indixed instead of 0-indexed,</span>
<span class="sd">        so that it is compatible with Bruker.</span>
<span class="sd">    tdf_bin_file_name : str</span>
<span class="sd">        The full file name of the SQL database &quot;analysis.tdf_bin&quot; in a Bruker</span>
<span class="sd">        .d folder.</span>
<span class="sd">    tims_offset_values : np.int64[:]</span>
<span class="sd">        The offsets that indicate the starting indices of each frame in the</span>
<span class="sd">        binary.</span>
<span class="sd">        These are contained in the &quot;TimsId&quot; column of the frames table in</span>
<span class="sd">        &quot;analysis.tdf_bin&quot;.</span>
<span class="sd">    scan_indptr : np.int64[:]</span>
<span class="sd">        A buffer containing zeros that can store the cumulative number of</span>
<span class="sd">        detections per scan.</span>
<span class="sd">        The size should be equal to max_scan_count * len(frames) + 1.</span>
<span class="sd">        A dummy 0-indexed frame is required to be present for len(frames).</span>
<span class="sd">        The last + 1 allows to explicitly interpret the end of a scan as</span>
<span class="sd">        the start of a subsequent scan.</span>
<span class="sd">    intensities : np.uint16[:]</span>
<span class="sd">        A buffer that can store the intensities of all detections.</span>
<span class="sd">        It&#39;s size can be determined by summing the &quot;NumPeaks&quot; column from</span>
<span class="sd">        the frames table in &quot;analysis.tdf_bin&quot;.</span>
<span class="sd">    tof_indices : np.uint32[:]</span>
<span class="sd">        A buffer that can store the tof indices of all detections.</span>
<span class="sd">        It&#39;s size can be determined by summing the &quot;NumPeaks&quot; column from</span>
<span class="sd">        the frames table in &quot;analysis.tdf_bin&quot;.</span>
<span class="sd">    frame_indptr : np.int64[:]</span>
<span class="sd">        The cumulative sum of the number of detections per frame.</span>
<span class="sd">        The size should be equal to len(frames) + 1.</span>
<span class="sd">        A dummy 0-indexed frame is required to be present for len(frames).</span>
<span class="sd">        The last + 1 allows to explicitly interpret the end of a frame as</span>
<span class="sd">        the start of a subsequent frame.</span>
<span class="sd">    max_scan_count : int</span>
<span class="sd">        The maximum number of scans a single frame can have.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pyzstd</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tdf_bin_file_name</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">tims_offset_values</span><span class="p">[</span><span class="n">frame_id</span><span class="p">]</span>
        <span class="n">infile</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">bin_size</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s2">&quot;little&quot;</span><span class="p">)</span>
        <span class="n">scan_count</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="s2">&quot;little&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_size</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="n">comp_data</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">bin_size</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span>
            <span class="n">decomp_data</span> <span class="o">=</span> <span class="n">pyzstd</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="n">comp_data</span><span class="p">)</span>
            <span class="p">(</span>
                <span class="n">scan_indices_</span><span class="p">,</span>
                <span class="n">tof_indices_</span><span class="p">,</span>
                <span class="n">intensities_</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">parse_decompressed_bruker_binary</span><span class="p">(</span><span class="n">decomp_data</span><span class="p">)</span>
            <span class="n">frame_start</span> <span class="o">=</span> <span class="n">frame_indptr</span><span class="p">[</span><span class="n">frame_id</span><span class="p">]</span>
            <span class="n">frame_end</span> <span class="o">=</span> <span class="n">frame_indptr</span><span class="p">[</span><span class="n">frame_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">scan_start</span> <span class="o">=</span> <span class="n">frame_id</span> <span class="o">*</span> <span class="n">max_scan_count</span>
            <span class="n">scan_end</span> <span class="o">=</span> <span class="n">scan_start</span> <span class="o">+</span> <span class="n">scan_count</span>
            <span class="n">scan_indptr</span><span class="p">[</span><span class="n">scan_start</span><span class="p">:</span> <span class="n">scan_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan_indices_</span>
            <span class="n">tof_indices</span><span class="p">[</span><span class="n">frame_start</span><span class="p">:</span> <span class="n">frame_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">tof_indices_</span>
            <span class="n">intensities</span><span class="p">[</span><span class="n">frame_start</span><span class="p">:</span> <span class="n">frame_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensities_</span></div>


<div class="viewcode-block" id="read_bruker_binary"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.read_bruker_binary">[docs]</a><span class="k">def</span> <span class="nf">read_bruker_binary</span><span class="p">(</span>
    <span class="n">frames</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">bruker_d_folder_name</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Read all data from an &quot;analysis.tdf_bin&quot; of a Bruker .d folder.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frames : pd.DataFrame</span>
<span class="sd">        The frames from the &quot;analysis.tdf&quot; SQL database of a Bruker .d folder.</span>
<span class="sd">        These can be acquired with e.g. alphatims.bruker.read_bruker_sql.</span>
<span class="sd">    bruker_d_folder_name : str</span>
<span class="sd">        The full path to a Bruker .d folder.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : tuple (np.int64[:], np.uint32[:], np.uint16[:]).</span>
<span class="sd">        The scan_indptr, tof_indices and intensities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frame_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">frame_indptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">frame_indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">NumPeaks</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">max_scan_count</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">NumScans</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">scan_count</span> <span class="o">=</span> <span class="n">max_scan_count</span> <span class="o">*</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scan_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">scan_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">frame_indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
    <span class="n">tof_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">frame_indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">tdf_bin_file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bruker_d_folder_name</span><span class="p">,</span> <span class="s2">&quot;analysis.tdf_bin&quot;</span><span class="p">)</span>
    <span class="n">tims_offset_values</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">TimsId</span><span class="o">.</span><span class="n">values</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Reading </span><span class="si">{</span><span class="n">frame_indptr</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">2</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> frames with &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">frame_indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2"> TOF arrivals for </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">process_frame</span><span class="p">(</span>
        <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)),</span>
        <span class="n">tdf_bin_file_name</span><span class="p">,</span>
        <span class="n">tims_offset_values</span><span class="p">,</span>
        <span class="n">scan_indptr</span><span class="p">,</span>
        <span class="n">intensities</span><span class="p">,</span>
        <span class="n">tof_indices</span><span class="p">,</span>
        <span class="n">frame_indptr</span><span class="p">,</span>
        <span class="n">max_scan_count</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">scan_indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">scan_indptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">scan_indptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">scan_indptr</span><span class="p">,</span> <span class="n">tof_indices</span><span class="p">,</span> <span class="n">intensities</span></div>


<div class="viewcode-block" id="TimsTOF"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF">[docs]</a><span class="k">class</span> <span class="nc">TimsTOF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that stores Bruker TimsTOF data in memory for fast access.</span>

<span class="sd">    Data can be read directly from a Bruker .d folder.</span>
<span class="sd">    All OS&#39;s are supported,</span>
<span class="sd">    but reading mz_values and mobility_values from a .d folder</span>
<span class="sd">    requires Windows or Linux due to availability of Bruker libraries.</span>
<span class="sd">    On MacOS, they are estimated based on metadata,</span>
<span class="sd">    but these values are not guaranteed to be correct.</span>
<span class="sd">    Often they fall within 0.02 Th, but errors up to 6 Th have already</span>
<span class="sd">    been observed!</span>

<span class="sd">    A TimsTOF object can also be exported to HDF for subsequent access.</span>
<span class="sd">    This file format is portable to all OS&#39;s.</span>
<span class="sd">    As such, initial reading on Windows with correct mz_values and</span>
<span class="sd">    mobility_values can be done and the resulting HDF file can</span>
<span class="sd">    safely be read on MacOS.</span>
<span class="sd">    This HDF file also provides improved accession times for subsequent use.</span>

<span class="sd">    After reading, data can be accessed with traditional Python slices.</span>
<span class="sd">    As TimsTOF data is 5-dimensional, the data can be sliced in 5 dimensions</span>
<span class="sd">    as well. These dimensions follows the design of the TimsTOF Pro:</span>

<span class="sd">        1 LC: rt_values, frame_indices</span>
<span class="sd">            The first dimension allows to slice retention_time values</span>
<span class="sd">            or frames indices. These values and indices</span>
<span class="sd">            have a one-to-one relationship.</span>
<span class="sd">        2 TIMS: mobility_values, scan_indices</span>
<span class="sd">            The second dimension allows to slice mobility values or</span>
<span class="sd">            scan indices (i.e. a single push).</span>
<span class="sd">            These values and indices have a one-to-one relationship.</span>
<span class="sd">        3 QUAD: quad_mz_values, precursor_indices</span>
<span class="sd">            The third dimension focusses on the quadrupole and indirectly</span>
<span class="sd">            on the collision cell. It allows to slice lower and upper</span>
<span class="sd">            quadrupole mz values (e.g. the m/z of</span>
<span class="sd">            unfragmented ions / precursors). If set to -1, the quadrupole and</span>
<span class="sd">            collision cell are assumed to be inactive, i.e. precursor ions</span>
<span class="sd">            are detected instead of fragments.</span>
<span class="sd">            Equally, this dimension allows to slice precursor indices.</span>
<span class="sd">            Precursor index 0 defaults to all precusors (i.e. quad mz values</span>
<span class="sd">            equal to -1). In DDA, precursor indices larger than 0 point</span>
<span class="sd">            to PASEF MSMS spectra.</span>
<span class="sd">            In DIA, precursor indices larger than 0 point to windows,</span>
<span class="sd">            i.e. all scans in a frame with equal quadrupole and collision</span>
<span class="sd">            settings that is repeated once per full cycle.</span>
<span class="sd">            Note that these values do not have a one-to-one relationship.</span>
<span class="sd">        4 TOF: mz_values, tof_indices</span>
<span class="sd">            The fourth dimension allows to slice (fragment) mz_values</span>
<span class="sd">            or tof indices. Note that the quadrupole dimension determines</span>
<span class="sd">            if precursors are detected or fragments.</span>
<span class="sd">            These values and indices have a one-to-one relationship.</span>
<span class="sd">        5 DETECTOR: intensity_values</span>
<span class="sd">            The fifth dimension allows to slice intensity values.</span>

<span class="sd">    Note that all dimensions except for the detector have both</span>
<span class="sd">    (float) values and (integer) indices.</span>
<span class="sd">    For each dimension, slices can be provided in several different ways:</span>

<span class="sd">        - int:</span>
<span class="sd">            A single int can be used to select a single index.</span>
<span class="sd">            If used in the fifth dimension, it still allows to select</span>
<span class="sd">            intensity_values</span>
<span class="sd">        - float:</span>
<span class="sd">            A single float can be used to select a single value.</span>
<span class="sd">            As the values arrays are discrete, the smallest index with a value</span>
<span class="sd">            equal to or larger than this value is actually selected.</span>
<span class="sd">            For intensity_value slicing, the exact value is used.</span>
<span class="sd">        - slice:</span>
<span class="sd">            A Python slice with start, stop and step can be provided.</span>
<span class="sd">            Start and stop values can independently be set to int or float.</span>
<span class="sd">            If a float is provided it conversed to an int as previously</span>
<span class="sd">            described.</span>
<span class="sd">            The step always needs to be provided as an int.</span>
<span class="sd">            Since there is not one-to-one relation from values to indices for</span>
<span class="sd">            QUAD and DETECTOR, the step value is ignored in these cases and</span>
<span class="sd">            only start and stop can be used.</span>

<span class="sd">            **IMPORTANT NOTE:** negative start, step and stop integers are not</span>
<span class="sd">            supported!</span>
<span class="sd">        - iterable:</span>
<span class="sd">            An iterable with (mixed) floats and ints can also be provided,</span>
<span class="sd">            in a similar fashion as Numpy&#39;s fancy indexing.</span>

<span class="sd">            **IMPORTANT NOTE:** The resulting integers after float-&gt;int</span>
<span class="sd">            conversion need to be sorted in ascending order!</span>
<span class="sd">        - np.ndarray:</span>
<span class="sd">            Multiple slicing is supported by providing either a</span>
<span class="sd">            np.int64[:, :, :] array, where each row is assumed to be a</span>
<span class="sd">            (start, stop, step) tuple or np.float64[:, :] where each row</span>
<span class="sd">            is assumed to be a (start, stop) tuple.</span>

<span class="sd">            **IMPORTANT NOTE:** These arrays need to be sorted,</span>
<span class="sd">            disjunct and strictly increasing</span>
<span class="sd">            (i.e. np.all(np.diff(precursor_slices[:, :2].ravel()) &gt;= 0)</span>
<span class="sd">            = True).</span>

<span class="sd">    Alternatively, a dictionary can be used to define filters for each</span>
<span class="sd">    dimension (see examples).</span>

<span class="sd">    The result of such slicing is a pd.DataFrame with the following columns:</span>

<span class="sd">        - raw_indices</span>
<span class="sd">        - frame_indices</span>
<span class="sd">        - scan_indices</span>
<span class="sd">        - precursor_indices</span>
<span class="sd">        - tof_indices</span>
<span class="sd">        - rt_values</span>
<span class="sd">        - mobility_values</span>
<span class="sd">        - quad_low_mz_values</span>
<span class="sd">        - quad_high_mz_values</span>
<span class="sd">        - mz_values</span>
<span class="sd">        - intensity_values</span>

<span class="sd">    Instead of returning a pd.DataFrame, raw indices can be returned by</span>
<span class="sd">    setting the last slice element to &quot;raw&quot;.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data[:100.0]</span>
<span class="sd">    # Return all datapoints with rt_values &lt; 100.0 seconds</span>

<span class="sd">    &gt;&gt;&gt; data[:, 450]</span>
<span class="sd">    # Return all datapoints with scan_index = 450</span>

<span class="sd">    &gt;&gt;&gt; data[:, :, 700.: 710.]</span>
<span class="sd">    # Return all datapoints with 700.0 &lt;= quad_mz_values &lt; 710.0</span>

<span class="sd">    &gt;&gt;&gt; data[:, :, :, 621.9: 191000]</span>
<span class="sd">    # Return all datapoints with 621.9 &lt;= mz_values and</span>
<span class="sd">    # tof_indices &lt; 191000</span>

<span class="sd">    &gt;&gt;&gt; data[[1, 8, 10], :, 0, 621.9: np.inf]</span>
<span class="sd">    # Return all datapoints from frames 1, 8 and 10, which are unfragmented</span>
<span class="sd">    # (precursor_index = 0) and with 621.9 &lt;= mz_values &lt; np.inf</span>

<span class="sd">    &gt;&gt;&gt; data[:, :, 999]</span>
<span class="sd">    # Return all datapoints from precursor 999</span>
<span class="sd">    # (for diaPASEF this is a traditional MSMS spectrum)</span>

<span class="sd">    &gt;&gt;&gt; scan_slices = np.array([[10, 20, 1], [100, 200, 10]])</span>
<span class="sd">    &gt;&gt;&gt; data[:, scan_slices, :, :, :]</span>
<span class="sd">    # Return all datapoints with scan_indices in range(10, 20) or</span>
<span class="sd">    # range(100, 200, 10)</span>

<span class="sd">    &gt;&gt;&gt; df = data[</span>
<span class="sd">    ...     {</span>
<span class="sd">    ...         &quot;frame_indices&quot;: [1, 191],</span>
<span class="sd">    ...         &quot;scan_indices&quot;: slice(300, 800, 10),</span>
<span class="sd">    ...         &quot;mz_values&quot;: slice(None, 400.5),</span>
<span class="sd">    ...         &quot;intensity_values&quot;: 50,</span>
<span class="sd">    ...     }</span>
<span class="sd">    ... ]</span>
<span class="sd">    # Slice by using a dictionary</span>

<span class="sd">    &gt;&gt;&gt; data[:, :, 999, &quot;raw&quot;]</span>
<span class="sd">    # Return the raw indices of datapoints from precursor 999</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: str : The sample name of this TimsTOF object.&quot;&quot;&quot;</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bruker_d_folder_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">directory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: str : The directory of this TimsTOF object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bruker_d_folder_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_compressed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: bool : HDF arraya are compressed or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compressed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: str : AlphaTims version used to create this TimsTOF object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_version</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">acquisition_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: str : The acquisition mode.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_acquisition_mode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">meta_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: dict : The metadata for the acquisition.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_meta_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rt_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.float64[:] : The rt values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rt_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mobility_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.float64[:] : The mobility values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mz_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.float64[:] : The mz values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quad_mz_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.float64[:, :] : The (low, high) quad mz values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_mz_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.uint16[:] : The intensity values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_values</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frame_max_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: int : The maximum frame index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frame_max_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scan_max_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: int : The maximum scan index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scan_max_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tof_max_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: int : The maximum tof index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tof_max_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">precursor_max_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: int : The maximum precursor index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precursor_max_index</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mz_min_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The minimum mz value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz_min_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mz_max_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The maximum mz value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mz_max_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rt_max_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The maximum rt value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quad_mz_min_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The minimum quad mz value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_min_mz_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quad_mz_max_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The maximum quad mz value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_max_mz_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mobility_min_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The minimum mobility value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_min_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mobility_max_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The maximum mobility value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_max_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_min_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The minimum intensity value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_min_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intensity_max_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: float : The maximum intensity value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_max_value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: pd.DataFrame : The frames table of the analysis.tdf SQL.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frames</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fragment_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: pd.DataFrame : The fragment frames table.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fragment_frames</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tof_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.uint32[:] : The tof indices.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tof_indices</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">push_indptr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.int64[:] : The tof indptr.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_push_indptr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">quad_indptr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.int64[:] : The quad indptr (tof_indices).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_indptr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw_quad_indptr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.int64[:] : The raw quad indptr (push indices).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_quad_indptr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">precursor_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;: np.ndarray : np.int64[:] : The precursor indices.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precursor_indices</span>

<div class="viewcode-block" id="TimsTOF.__init__"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bruker_d_folder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">mz_estimation_from_frame</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">mobility_estimation_from_frame</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">slice_as_dataframe</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a Bruker TimsTOF object that contains all data in-memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bruker_d_folder_name : str</span>
<span class="sd">            The full file name to a Bruker .d folder.</span>
<span class="sd">            Alternatively, the full file name of an already exported .hdf</span>
<span class="sd">            can be provided as well.</span>
<span class="sd">        mz_estimation_from_frame : int</span>
<span class="sd">            If larger than 0, mz_values from this frame are read as</span>
<span class="sd">            default mz_values with the Bruker library.</span>
<span class="sd">            If 0, mz_values are being estimated with the metadata</span>
<span class="sd">            based on &quot;MzAcqRangeLower&quot; and &quot;MzAcqRangeUpper&quot;.</span>
<span class="sd">            IMPORTANT NOTE: MacOS defaults to 0, as no Bruker library</span>
<span class="sd">            is available.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        mobility_estimation_from_frame : int</span>
<span class="sd">            If larger than 0, mobility_values from this frame are read as</span>
<span class="sd">            default mobility_values with the Bruker library.</span>
<span class="sd">            If 0, mobility_values are being estimated with the metadata</span>
<span class="sd">            based on &quot;OneOverK0AcqRangeLower&quot; and &quot;OneOverK0AcqRangeUpper&quot;.</span>
<span class="sd">            IMPORTANT NOTE: MacOS defaults to 0, as no Bruker library</span>
<span class="sd">            is available.</span>
<span class="sd">            Default is 1.</span>
<span class="sd">        slice_as_dataframe : bool</span>
<span class="sd">            If True, slicing returns a pd.DataFrame by default.</span>
<span class="sd">            If False, slicing provides a np.int64[:] with raw indices.</span>
<span class="sd">            This value can also be modified after creation.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bruker_d_folder_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">bruker_d_folder_name</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Importing data from </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bruker_d_folder_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.d&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_import_data_from_d_folder</span><span class="p">(</span>
                <span class="n">bruker_d_folder_name</span><span class="p">,</span>
                <span class="n">mz_estimation_from_frame</span><span class="p">,</span>
                <span class="n">mobility_estimation_from_frame</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">bruker_d_folder_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.hdf&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_import_data_from_hdf_file</span><span class="p">(</span>
                <span class="n">bruker_d_folder_name</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;version&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">!=</span> <span class="n">alphatims</span><span class="o">.</span><span class="n">__version__</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;AlphaTims version </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2"> was used to initialize &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">, while the current version of &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;AlphaTims is </span><span class="si">{</span><span class="n">alphatims</span><span class="o">.</span><span class="n">__version__</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Succesfully imported data from </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slice_as_dataframe</span> <span class="o">=</span> <span class="n">slice_as_dataframe</span>
        <span class="c1"># Precompile</span>
        <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;raw&quot;</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_import_data_from_d_folder</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bruker_d_folder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">mz_estimation_from_frame</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">mobility_estimation_from_frame</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_version</span> <span class="o">=</span> <span class="n">alphatims</span><span class="o">.</span><span class="n">__version__</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquisition_mode</span><span class="p">,</span>
            <span class="n">global_meta_data</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_frames</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fragment_frames</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">read_bruker_sql</span><span class="p">(</span><span class="n">bruker_d_folder_name</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_indptr</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tof_indices</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_values</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">read_bruker_binary</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">,</span>
            <span class="n">bruker_d_folder_name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_meta_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">global_meta_data</span><span class="o">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">global_meta_data</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_max_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scan_max_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">NumScans</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tof_max_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;DigitizerNumSamples&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rt_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">Time</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_min_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;OneOverK0AcqRangeLower&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_max_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;OneOverK0AcqRangeUpper&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">bruker_dll_available</span> <span class="o">=</span> <span class="n">BRUKER_DLL_FILE_NAME</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mobility_estimation_from_frame</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bruker_dll_available</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">ctypes</span>
            <span class="k">with</span> <span class="n">alphatims</span><span class="o">.</span><span class="n">bruker</span><span class="o">.</span><span class="n">open_bruker_d_folder</span><span class="p">(</span>
                <span class="n">bruker_d_folder_name</span>
            <span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">bruker_dll</span><span class="p">,</span> <span class="n">bruker_d_folder_handle</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Fetching mobility values from </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_scannum_to_oneoverk0</span><span class="p">(</span>
                    <span class="n">bruker_d_folder_handle</span><span class="p">,</span>
                    <span class="n">mobility_estimation_from_frame</span><span class="p">,</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span>
                        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mobility_values</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span>
                        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mobility_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobility_max_value</span> <span class="o">-</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mobility_max_value</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobility_min_value</span>
            <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mz_min_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;MzAcqRangeLower&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mz_max_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;MzAcqRangeUpper&quot;</span><span class="p">])</span>
        <span class="n">tof_intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mz_min_value</span><span class="p">)</span>
        <span class="n">tof_slope</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mz_max_value</span><span class="p">)</span> <span class="o">-</span> <span class="n">tof_intercept</span>
        <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tof_max_index</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mz_estimation_from_frame</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bruker_dll_available</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">ctypes</span>
            <span class="k">with</span> <span class="n">alphatims</span><span class="o">.</span><span class="n">bruker</span><span class="o">.</span><span class="n">open_bruker_d_folder</span><span class="p">(</span>
                <span class="n">bruker_d_folder_name</span>
            <span class="p">)</span> <span class="k">as</span> <span class="p">(</span><span class="n">bruker_dll</span><span class="p">,</span> <span class="n">bruker_d_folder_handle</span><span class="p">):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Fetching mz values from </span><span class="si">{</span><span class="n">bruker_d_folder_name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tof_max_index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mz_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="n">bruker_dll</span><span class="o">.</span><span class="n">tims_index_to_mz</span><span class="p">(</span>
                    <span class="n">bruker_d_folder_handle</span><span class="p">,</span>
                    <span class="n">mz_estimation_from_frame</span><span class="p">,</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span>
                        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mz_values</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data_as</span><span class="p">(</span>
                        <span class="n">ctypes</span><span class="o">.</span><span class="n">POINTER</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span><span class="p">)</span>
                    <span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tof_max_index</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mz_values</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tof_intercept</span> <span class="o">+</span> <span class="n">tof_slope</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tof_max_index</span><span class="p">)</span>
            <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_quad_indptr</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_min_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_max_value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span><span class="p">))</span>

<div class="viewcode-block" id="TimsTOF.save_as_hdf"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.save_as_hdf">[docs]</a>    <span class="k">def</span> <span class="nf">save_as_hdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">file_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">compress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_as_bytes_io</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the TimsTOF object as an hdf file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        directory : str</span>
<span class="sd">            The directory where to save the HDF file.</span>
<span class="sd">            Ignored if return_as_bytes_io == True.</span>
<span class="sd">        file_name : str</span>
<span class="sd">            The file name of the  HDF file.</span>
<span class="sd">            Ignored if return_as_bytes_io == True.</span>
<span class="sd">        overwrite : bool</span>
<span class="sd">            If True, an existing file is truncated.</span>
<span class="sd">            If False, the existing file is appended to only if the original</span>
<span class="sd">            group, array or property does not exist yet.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        compress : bool</span>
<span class="sd">            If True, compression is used.</span>
<span class="sd">            This roughly halves files sizes (on-disk),</span>
<span class="sd">            at the cost of taking 3-6 longer accession times.</span>
<span class="sd">            See also alphatims.utils.create_hdf_group_from_dict.</span>
<span class="sd">            If False, no compression is used</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_as_bytes_io</span>
<span class="sd">            If True, the HDF file is only created in memory and returned</span>
<span class="sd">            as a bytes stream.</span>
<span class="sd">            If False, the file is written to disk.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str, io.BytesIO</span>
<span class="sd">            The full file name or a bytes stream containing the HDF file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">io</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">hdf_mode</span> <span class="o">=</span> <span class="s2">&quot;w&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hdf_mode</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
        <span class="k">if</span> <span class="n">return_as_bytes_io</span><span class="p">:</span>
            <span class="n">full_file_name</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full_file_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">directory</span><span class="p">,</span>
                <span class="n">file_name</span>
            <span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Writing TimsTOF data to </span><span class="si">{</span><span class="n">full_file_name</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compressed</span> <span class="o">=</span> <span class="n">compress</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">full_file_name</span><span class="p">,</span> <span class="n">hdf_mode</span><span class="p">,</span> <span class="n">swmr</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_root</span><span class="p">:</span>
            <span class="n">alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">create_hdf_group_from_dict</span><span class="p">(</span>
                <span class="n">hdf_root</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;raw&quot;</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span>
                <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                <span class="n">compress</span><span class="o">=</span><span class="n">compress</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_as_bytes_io</span><span class="p">:</span>
            <span class="n">full_file_name</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Succesfully wrote TimsTOF data to </span><span class="si">{</span><span class="n">full_file_name</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">full_file_name</span></div>

    <span class="k">def</span> <span class="nf">_import_data_from_hdf_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bruker_d_folder_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">bruker_d_folder_name</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hdf_root</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="n">alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">create_dict_from_hdf_group</span><span class="p">(</span>
                <span class="n">hdf_root</span><span class="p">[</span><span class="s2">&quot;raw&quot;</span><span class="p">]</span>
            <span class="p">)</span>

<div class="viewcode-block" id="TimsTOF.convert_from_indices"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.convert_from_indices">[docs]</a>    <span class="k">def</span> <span class="nf">convert_from_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">raw_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">frame_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">quad_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scan_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tof_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_raw_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_frame_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_scan_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_quad_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_tof_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_precursor_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_rt_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_mobility_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_quad_mz_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_mz_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_intensity_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">raw_indices_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convert selected indices to a dict.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        raw_indices : np.int64[:], None</span>
<span class="sd">            The raw indices for which coordinates need to be retrieved.</span>
<span class="sd">        frame_indices : np.int64[:], None</span>
<span class="sd">            The frame indices for which coordinates need to be retrieved.</span>
<span class="sd">        quad_indices : np.int64[:], None</span>
<span class="sd">            The quad indices for which coordinates need to be retrieved.</span>
<span class="sd">        scan_indices : np.int64[:], None</span>
<span class="sd">            The scan indices for which coordinates need to be retrieved.</span>
<span class="sd">        tof_indices : np.int64[:], None</span>
<span class="sd">            The tof indices for which coordinates need to be retrieved.</span>
<span class="sd">        return_raw_indices : bool</span>
<span class="sd">            If True, include &quot;raw_indices&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_frame_indices : bool</span>
<span class="sd">            If True, include &quot;frame_indices&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_scan_indices : bool</span>
<span class="sd">            If True, include &quot;scan_indices&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_quad_indices : bool</span>
<span class="sd">            If True, include &quot;quad_indices&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_tof_indices : bool</span>
<span class="sd">            If True, include &quot;tof_indices&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_precursor_indices : bool</span>
<span class="sd">            If True, include &quot;precursor_indices&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_rt_values : bool</span>
<span class="sd">            If True, include &quot;rt_values&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_mobility_values : bool</span>
<span class="sd">            If True, include &quot;mobility_values&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_quad_mz_values : bool</span>
<span class="sd">            If True, include &quot;quad_low_mz_values&quot; and</span>
<span class="sd">            &quot;quad_high_mz_values&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_mz_values : bool</span>
<span class="sd">            If True, include &quot;mz_values&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_intensity_values : bool</span>
<span class="sd">            If True, include &quot;intensity_values&quot; in the dict.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        raw_indices_sorted : bool</span>
<span class="sd">            If True, raw_indices are assumed to be sorted,</span>
<span class="sd">            resulting in a faster conversion.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            A dict with all requested columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">raw_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">return_frame_indices</span><span class="p">,</span>
                <span class="n">return_scan_indices</span><span class="p">,</span>
                <span class="n">return_quad_indices</span><span class="p">,</span>
                <span class="n">return_rt_values</span><span class="p">,</span>
                <span class="n">return_mobility_values</span><span class="p">,</span>
                <span class="n">return_quad_mz_values</span><span class="p">,</span>
                <span class="n">return_precursor_indices</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">raw_indices_sorted</span><span class="p">:</span>
                <span class="n">parsed_indices</span> <span class="o">=</span> <span class="n">indptr_lookup</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">push_indptr</span><span class="p">,</span>
                    <span class="n">raw_indices</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parsed_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">push_indptr</span><span class="p">,</span>
                    <span class="n">raw_indices</span><span class="p">,</span>
                    <span class="s2">&quot;right&quot;</span>
                <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">return_frame_indices</span> <span class="ow">or</span> <span class="n">return_rt_values</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">frame_indices</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">frame_indices</span> <span class="o">=</span> <span class="n">parsed_indices</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">return_scan_indices</span> <span class="ow">or</span> <span class="n">return_mobility_values</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">scan_indices</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">scan_indices</span> <span class="o">=</span> <span class="n">parsed_indices</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">return_quad_indices</span><span class="p">,</span>
                <span class="n">return_quad_mz_values</span><span class="p">,</span>
                <span class="n">return_precursor_indices</span>
            <span class="p">]</span>
        <span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">quad_indices</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">raw_indices_sorted</span><span class="p">:</span>
                <span class="n">quad_indices</span> <span class="o">=</span> <span class="n">indptr_lookup</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">quad_indptr</span><span class="p">,</span>
                    <span class="n">raw_indices</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quad_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">quad_indptr</span><span class="p">,</span>
                    <span class="n">raw_indices</span><span class="p">,</span>
                    <span class="s2">&quot;right&quot;</span>
                <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">return_tof_indices</span> <span class="ow">or</span> <span class="n">return_mz_values</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tof_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">tof_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tof_indices</span><span class="p">[</span><span class="n">raw_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_raw_indices</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;raw_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_indices</span>
        <span class="k">if</span> <span class="n">return_frame_indices</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;frame_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">frame_indices</span>
        <span class="k">if</span> <span class="n">return_scan_indices</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;scan_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scan_indices</span>
        <span class="k">if</span> <span class="n">return_quad_indices</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;quad_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad_indices</span>
        <span class="k">if</span> <span class="n">return_precursor_indices</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;precursor_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">precursor_indices</span><span class="p">[</span><span class="n">quad_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_tof_indices</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;tof_indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tof_indices</span>
        <span class="k">if</span> <span class="n">return_rt_values</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;rt_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rt_values</span><span class="p">[</span><span class="n">frame_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_mobility_values</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mobility_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mobility_values</span><span class="p">[</span><span class="n">scan_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_quad_mz_values</span><span class="p">:</span>
            <span class="n">selected_quad_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quad_mz_values</span><span class="p">[</span><span class="n">quad_indices</span><span class="p">]</span>
            <span class="n">low_mz_values</span> <span class="o">=</span> <span class="n">selected_quad_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">high_mz_values</span> <span class="o">=</span> <span class="n">selected_quad_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;quad_low_mz_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">low_mz_values</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;quad_high_mz_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">high_mz_values</span>
        <span class="k">if</span> <span class="n">return_mz_values</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;mz_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mz_values</span><span class="p">[</span><span class="n">tof_indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">return_intensity_values</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s2">&quot;intensity_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span><span class="p">[</span><span class="n">raw_indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="TimsTOF.convert_to_indices"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.convert_to_indices">[docs]</a>    <span class="k">def</span> <span class="nf">convert_to_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">return_frame_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_scan_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">return_tof_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">side</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">return_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert selected values to a pd.DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : float, np.float64[...], iterable</span>
<span class="sd">            The raw values for which indices need to be retrieved.</span>
<span class="sd">        return_frame_indices : bool</span>
<span class="sd">            If True, convert the values to &quot;frame_indices&quot;.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_scan_indices : bool</span>
<span class="sd">            If True, convert the values to &quot;scan_indices&quot;.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        return_tof_indices : bool</span>
<span class="sd">            If True, convert the values to &quot;tof_indices&quot;.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        side : str</span>
<span class="sd">            If there is an exact match between the values and reference array,</span>
<span class="sd">            which index should be chosen. See also np.searchsorted.</span>
<span class="sd">            Options are &quot;left&quot; or &quot;right&quot;.</span>
<span class="sd">            Default is &quot;left&quot;.</span>
<span class="sd">        return_type : str</span>
<span class="sd">            Alternative way to define the return type.</span>
<span class="sd">            Options are &quot;frame_indices&quot;, &quot;scan_indices&quot; or &quot;tof_indices&quot;.</span>
<span class="sd">            Default is &quot;&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.int64[...], int</span>
<span class="sd">            An array with the same shape as values or iterable or an int</span>
<span class="sd">            which corresponds to the requested value.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        PrecursorFloatError</span>
<span class="sd">            When trying to convert a quad float other than np.inf or -np.inf</span>
<span class="sd">            to precursor index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">return_frame_indices</span><span class="p">:</span>
            <span class="n">return_type</span> <span class="o">=</span> <span class="s2">&quot;frame_indices&quot;</span>
        <span class="k">elif</span> <span class="n">return_scan_indices</span><span class="p">:</span>
            <span class="n">return_type</span> <span class="o">=</span> <span class="s2">&quot;scan_indices&quot;</span>
        <span class="k">elif</span> <span class="n">return_tof_indices</span><span class="p">:</span>
            <span class="n">return_type</span> <span class="o">=</span> <span class="s2">&quot;tof_indices&quot;</span>
        <span class="k">if</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s2">&quot;frame_indices&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rt_values</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s2">&quot;scan_indices&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mobility_values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">values</span><span class="p">,</span>
                <span class="s2">&quot;left&quot;</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span> <span class="k">else</span> <span class="s2">&quot;right&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s2">&quot;tof_indices&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mz_values</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">return_type</span> <span class="o">==</span> <span class="s2">&quot;precursor_indices&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">values</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="n">PrecursorFloatError</span><span class="p">(</span>
                        <span class="s2">&quot;Can not convert values to precursor_indices&quot;</span>
                    <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PrecursorFloatError</span><span class="p">(</span>
                    <span class="s2">&quot;Can not convert values to precursor_indices&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">values</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">values</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">precursor_max_index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;return_type &#39;</span><span class="si">{</span><span class="n">return_type</span><span class="si">}</span><span class="s2">&#39; is invalid&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">keys</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;df&quot;</span><span class="p">:</span>
                <span class="n">as_dataframe</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;raw&quot;</span><span class="p">:</span>
                <span class="n">as_dataframe</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot use </span><span class="si">{</span><span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> as a key&quot;</span><span class="p">)</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">as_dataframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_as_dataframe</span>
        <span class="n">parsed_keys</span> <span class="o">=</span> <span class="n">parse_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>
        <span class="n">raw_indices</span> <span class="o">=</span> <span class="n">filter_indices</span><span class="p">(</span>
            <span class="n">frame_slices</span><span class="o">=</span><span class="n">parsed_keys</span><span class="p">[</span><span class="s2">&quot;frame_indices&quot;</span><span class="p">],</span>
            <span class="n">scan_slices</span><span class="o">=</span><span class="n">parsed_keys</span><span class="p">[</span><span class="s2">&quot;scan_indices&quot;</span><span class="p">],</span>
            <span class="n">precursor_slices</span><span class="o">=</span><span class="n">parsed_keys</span><span class="p">[</span><span class="s2">&quot;precursor_indices&quot;</span><span class="p">],</span>
            <span class="n">tof_slices</span><span class="o">=</span><span class="n">parsed_keys</span><span class="p">[</span><span class="s2">&quot;tof_indices&quot;</span><span class="p">],</span>
            <span class="n">quad_slices</span><span class="o">=</span><span class="n">parsed_keys</span><span class="p">[</span><span class="s2">&quot;quad_values&quot;</span><span class="p">],</span>
            <span class="n">intensity_slices</span><span class="o">=</span><span class="n">parsed_keys</span><span class="p">[</span><span class="s2">&quot;intensity_values&quot;</span><span class="p">],</span>
            <span class="n">frame_max_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_max_index</span><span class="p">,</span>
            <span class="n">scan_max_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span><span class="p">,</span>
            <span class="n">push_indptr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">push_indptr</span><span class="p">,</span>
            <span class="n">precursor_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">precursor_indices</span><span class="p">,</span>
            <span class="n">quad_mz_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_mz_values</span><span class="p">,</span>
            <span class="n">quad_indptr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_indptr</span><span class="p">,</span>
            <span class="n">tof_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tof_indices</span><span class="p">,</span>
            <span class="n">intensities</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">as_dataframe</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_dataframe</span><span class="p">(</span><span class="n">raw_indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">raw_indices</span>

<div class="viewcode-block" id="TimsTOF.bin_intensities"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.bin_intensities">[docs]</a>    <span class="k">def</span> <span class="nf">bin_intensities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sum and project the intensities of the indices along 1 or 2 axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : np.int64[:]</span>
<span class="sd">            The selected indices whose coordinates need to be summed along</span>
<span class="sd">            the selected axis.</span>
<span class="sd">        axis : tuple</span>
<span class="sd">            Must be length 1 or 2 and can only contain the elements</span>
<span class="sd">            &quot;rt_values&quot;, &quot;mobility_values&quot; and &quot;mz_values&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.float64[:], np.float64[:, :]</span>
<span class="sd">            An array or heatmap that express the summed intensity along</span>
<span class="sd">            the selected axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">max_index</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;rt_values&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_max_index</span><span class="p">,</span>
            <span class="s2">&quot;mobility_values&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span><span class="p">,</span>
            <span class="s2">&quot;mz_values&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tof_max_index</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">parsed_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_from_indices</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="n">return_frame_indices</span><span class="o">=</span><span class="s2">&quot;rt_values&quot;</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">,</span>
            <span class="n">return_scan_indices</span><span class="o">=</span><span class="s2">&quot;mobility_values&quot;</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">,</span>
            <span class="n">return_tof_indices</span><span class="o">=</span><span class="s2">&quot;mz_values&quot;</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">binned_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">max_index</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]))</span>
        <span class="n">parse_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;rt_values&quot;</span><span class="p">:</span> <span class="s2">&quot;frame_indices&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mobility_values&quot;</span><span class="p">:</span> <span class="s2">&quot;scan_indices&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mz_values&quot;</span><span class="p">:</span> <span class="s2">&quot;tof_indices&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">add_intensity_to_bin</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
            <span class="n">intensities</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">parsed_indices</span><span class="p">[</span><span class="n">parse_dict</span><span class="p">[</span><span class="n">ax</span><span class="p">]]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span>
                <span class="p">]</span>
            <span class="p">),</span>
            <span class="n">binned_intensities</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">binned_intensities</span></div>

<div class="viewcode-block" id="TimsTOF.as_dataframe"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.as_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">as_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">raw_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">frame_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">scan_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">quad_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">tof_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">precursor_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">rt_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mobility_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">quad_mz_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mz_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">intensity_values</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">raw_indices_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert raw indices to a pd.DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : np.int64[:]</span>
<span class="sd">            The raw indices for which coordinates need to be retrieved.</span>
<span class="sd">        raw_indices : bool</span>
<span class="sd">            If True, include &quot;raw_indices&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        frame_indices : bool</span>
<span class="sd">            If True, include &quot;frame_indices&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        scan_indices : bool</span>
<span class="sd">            If True, include &quot;scan_indices&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        quad_indices : bool</span>
<span class="sd">            If True, include &quot;quad_indices&quot; in the dataframe.</span>
<span class="sd">            Default is False.</span>
<span class="sd">        tof_indices : bool</span>
<span class="sd">            If True, include &quot;tof_indices&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        precursor_indices : bool</span>
<span class="sd">            If True, include &quot;precursor_indices&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        rt_values : bool</span>
<span class="sd">            If True, include &quot;rt_values&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        mobility_values : bool</span>
<span class="sd">            If True, include &quot;mobility_values&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        quad_mz_values : bool</span>
<span class="sd">            If True, include &quot;quad_low_mz_values&quot; and</span>
<span class="sd">            &quot;quad_high_mz_values&quot; in the dict.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        mz_values : bool</span>
<span class="sd">            If True, include &quot;mz_values&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        intensity_values : bool</span>
<span class="sd">            If True, include &quot;intensity_values&quot; in the dataframe.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        raw_indices_sorted : bool</span>
<span class="sd">            If True, raw_indices are assumed to be sorted,</span>
<span class="sd">            resulting in a faster conversion.</span>
<span class="sd">            Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">            A dataframe with all requested columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
           <span class="bp">self</span><span class="o">.</span><span class="n">convert_from_indices</span><span class="p">(</span>
                <span class="n">indices</span><span class="p">,</span>
                <span class="n">return_raw_indices</span><span class="o">=</span><span class="n">raw_indices</span><span class="p">,</span>
                <span class="n">return_frame_indices</span><span class="o">=</span><span class="n">frame_indices</span><span class="p">,</span>
                <span class="n">return_scan_indices</span><span class="o">=</span><span class="n">scan_indices</span><span class="p">,</span>
                <span class="n">return_quad_indices</span><span class="o">=</span><span class="n">quad_indices</span><span class="p">,</span>
                <span class="n">return_precursor_indices</span><span class="o">=</span><span class="n">precursor_indices</span><span class="p">,</span>
                <span class="n">return_tof_indices</span><span class="o">=</span><span class="n">tof_indices</span><span class="p">,</span>
                <span class="n">return_rt_values</span><span class="o">=</span><span class="n">rt_values</span><span class="p">,</span>
                <span class="n">return_mobility_values</span><span class="o">=</span><span class="n">mobility_values</span><span class="p">,</span>
                <span class="n">return_quad_mz_values</span><span class="o">=</span><span class="n">quad_mz_values</span><span class="p">,</span>
                <span class="n">return_mz_values</span><span class="o">=</span><span class="n">mz_values</span><span class="p">,</span>
                <span class="n">return_intensity_values</span><span class="o">=</span><span class="n">intensity_values</span><span class="p">,</span>
                <span class="n">raw_indices_sorted</span><span class="o">=</span><span class="n">raw_indices_sorted</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_parse_quad_indptr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frame_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_frames</span><span class="o">.</span><span class="n">Frame</span><span class="o">.</span><span class="n">values</span>
        <span class="n">scan_begins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_frames</span><span class="o">.</span><span class="n">ScanNumBegin</span><span class="o">.</span><span class="n">values</span>
        <span class="n">scan_ends</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_frames</span><span class="o">.</span><span class="n">ScanNumEnd</span><span class="o">.</span><span class="n">values</span>
        <span class="n">isolation_mzs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_frames</span><span class="o">.</span><span class="n">IsolationMz</span><span class="o">.</span><span class="n">values</span>
        <span class="n">isolation_widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_frames</span><span class="o">.</span><span class="n">IsolationWidth</span><span class="o">.</span><span class="n">values</span>
        <span class="n">precursors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_frames</span><span class="o">.</span><span class="n">Precursor</span><span class="o">.</span><span class="n">values</span>
        <span class="n">scan_max_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_max_index</span>
        <span class="n">frame_max_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_max_index</span>
        <span class="n">quad_indptr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">quad_low_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quad_high_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">precursor_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">high</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span>
            <span class="n">frame_id</span><span class="p">,</span>
            <span class="n">scan_begin</span><span class="p">,</span>
            <span class="n">scan_end</span><span class="p">,</span>
            <span class="n">isolation_mz</span><span class="p">,</span>
            <span class="n">isolation_width</span><span class="p">,</span>
            <span class="n">precursor</span>
        <span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">frame_ids</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">scan_begins</span><span class="p">,</span>
            <span class="n">scan_ends</span><span class="p">,</span>
            <span class="n">isolation_mzs</span><span class="p">,</span>
            <span class="n">isolation_widths</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">precursors</span>
        <span class="p">):</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">frame_id</span> <span class="o">*</span> <span class="n">scan_max_index</span> <span class="o">+</span> <span class="n">scan_begin</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="p">:</span>
                <span class="n">quad_indptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">low</span><span class="p">)</span>
                <span class="n">quad_low_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">quad_high_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">precursor_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">high</span> <span class="o">=</span> <span class="n">frame_id</span> <span class="o">*</span> <span class="n">scan_max_index</span> <span class="o">+</span> <span class="n">scan_end</span>
            <span class="n">quad_indptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">high</span><span class="p">)</span>
            <span class="n">quad_low_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isolation_mz</span> <span class="o">-</span> <span class="n">isolation_width</span><span class="p">)</span>
            <span class="n">quad_high_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isolation_mz</span> <span class="o">+</span> <span class="n">isolation_width</span><span class="p">)</span>
            <span class="n">precursor_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">precursor</span><span class="p">)</span>
        <span class="n">quad_max_index</span> <span class="o">=</span> <span class="n">scan_max_index</span> <span class="o">*</span> <span class="n">frame_max_index</span>
        <span class="k">if</span> <span class="n">high</span> <span class="o">&lt;</span> <span class="n">quad_max_index</span><span class="p">:</span>
            <span class="n">quad_indptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quad_max_index</span><span class="p">)</span>
            <span class="n">quad_low_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">quad_high_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">precursor_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_mz_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">quad_low_values</span><span class="p">,</span> <span class="n">quad_high_values</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_precursor_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">precursor_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_quad_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quad_indptr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_indptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">push_indptr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_quad_indptr</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_max_mz_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_mz_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_min_mz_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quad_mz_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_precursor_max_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">precursor_indices</span><span class="p">))</span>

<div class="viewcode-block" id="TimsTOF.index_precursors"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.TimsTOF.index_precursors">[docs]</a>    <span class="k">def</span> <span class="nf">index_precursors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieve all MS2 spectra acquired with DDA.</span>

<span class="sd">        IMPORTANT NOTE: WThis function is intended for DDA samples.</span>
<span class="sd">        While it in theory works for DIA sample too, this probably has little</span>
<span class="sd">        value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : tuple (np.int64[:], np.uint32[:], np.uint32[:])</span>
<span class="sd">            The spectrum_indptr array, spectrum_tof_indices array and</span>
<span class="sd">            spectrum_intensity_values array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">precursor_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">precursor_indices</span><span class="p">)</span>
        <span class="n">precursor_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precursor_max_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span>
        <span class="p">)</span>
        <span class="n">precursor_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">precursor_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">precursor_indices</span><span class="p">[</span><span class="n">precursor_order</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">precursor_offsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precursor_order</span><span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">precursor_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">precursor_order</span><span class="p">[</span><span class="n">offset</span><span class="p">:]</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
        <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad_indptr</span><span class="p">[</span><span class="n">offsets</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">quad_indptr</span><span class="p">[</span><span class="n">offsets</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">spectrum_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">precursor_max_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span>
        <span class="p">)</span>
        <span class="n">spectrum_indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span>
            <span class="n">precursor_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">precursor_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="n">spectrum_indptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_spectrum_indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">spectrum_indptr</span><span class="p">)</span>
        <span class="n">spectrum_tof_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">spectrum_indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">spectrum_intensity_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">spectrum_tof_indices</span><span class="p">)</span>
        <span class="n">set_precursor</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precursor_max_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">precursor_order</span><span class="p">,</span>
            <span class="n">precursor_offsets</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quad_indptr</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tof_indices</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_values</span><span class="p">,</span>
            <span class="n">spectrum_tof_indices</span><span class="p">,</span>
            <span class="n">spectrum_intensity_values</span><span class="p">,</span>
            <span class="n">spectrum_indptr</span><span class="p">,</span>
            <span class="n">new_spectrum_indptr</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_spectrum_indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">new_spectrum_indptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">new_spectrum_indptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">trimmed_spectrum_tof_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">new_spectrum_indptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="n">trimmed_spectrum_intensity_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span>
            <span class="n">trimmed_spectrum_tof_indices</span>
        <span class="p">)</span>
        <span class="n">spectrum_intensity_values</span>
        <span class="n">trim_spectra</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precursor_max_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">spectrum_tof_indices</span><span class="p">,</span>
            <span class="n">spectrum_intensity_values</span><span class="p">,</span>
            <span class="n">spectrum_indptr</span><span class="p">,</span>
            <span class="n">trimmed_spectrum_tof_indices</span><span class="p">,</span>
            <span class="n">trimmed_spectrum_intensity_values</span><span class="p">,</span>
            <span class="n">new_spectrum_indptr</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">new_spectrum_indptr</span><span class="p">,</span>
            <span class="n">trimmed_spectrum_tof_indices</span><span class="p">,</span>
            <span class="n">trimmed_spectrum_intensity_values</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="PrecursorFloatError"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.PrecursorFloatError">[docs]</a><span class="k">class</span> <span class="nc">PrecursorFloatError</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used to indicate that a precursor value is not an int but a float.&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="set_precursor"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.set_precursor">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">pjit</span><span class="p">(</span>
    <span class="n">signature_or_function</span><span class="o">=</span><span class="s2">&quot;void(i8,i8[:],i8[:],i8[:],u4[:],u2[:],u4[:],u4[:],i8[:],i8[:])&quot;</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">set_precursor</span><span class="p">(</span>
    <span class="n">precursor_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">offset_order</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">precursor_offsets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">quad_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tof_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">intensities</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spectrum_tof_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spectrum_intensity_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spectrum_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spectrum_counts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Sum the intensities of all pushes belonging to a single precursor.</span>

<span class="sd">    IMPORTANT NOTE: This function is decorate with alphatims.utils.pjit.</span>
<span class="sd">    The first argument is thus expected to be provided as an iterable</span>
<span class="sd">    containing ints instead of a single int.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    precursor_index : int</span>
<span class="sd">        The precursor index indicating which MS2 spectrum to determine.</span>
<span class="sd">    offset_order : np.int64[:]</span>
<span class="sd">        The order of self.precursor_indices, obtained with np.argsort.</span>
<span class="sd">    precursor_offsets : np.int64[:]</span>
<span class="sd">        An index pointer array for precursor offsets.</span>
<span class="sd">    quad_indptr : np.int64[:]</span>
<span class="sd">        The self.quad_indptr array of a TimsTOF object.</span>
<span class="sd">    tof_indices : np.uint32[:]</span>
<span class="sd">        The self.tof_indices array of a TimsTOF object.</span>
<span class="sd">    intensities : np.uint16[:]</span>
<span class="sd">        The self.intensity_values array of a TimsTOF object.</span>
<span class="sd">    spectrum_tof_indices : np.uint32[:]</span>
<span class="sd">        A buffer array to store tof indices of the new spectrum.</span>
<span class="sd">    spectrum_intensity_values : np.uint32[:]</span>
<span class="sd">        A buffer array to store intensity values of the new spectrum.</span>
<span class="sd">    spectrum_indptr : np.int64[:]</span>
<span class="sd">        An index pointer array defining the original spectrum boundaries.</span>
<span class="sd">    spectrum_counts :  np. int64[:]</span>
<span class="sd">        An buffer array defining how many distinct tof indices the new</span>
<span class="sd">        spectrum has.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">spectrum_indptr</span><span class="p">[</span><span class="n">precursor_index</span><span class="p">]</span>
    <span class="n">precursor_offset_lower</span> <span class="o">=</span> <span class="n">precursor_offsets</span><span class="p">[</span><span class="n">precursor_index</span><span class="p">]</span>
    <span class="n">precursor_offset_upper</span> <span class="o">=</span> <span class="n">precursor_offsets</span><span class="p">[</span><span class="n">precursor_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">selected_offsets</span> <span class="o">=</span> <span class="n">offset_order</span><span class="p">[</span>
        <span class="n">precursor_offset_lower</span><span class="p">:</span> <span class="n">precursor_offset_upper</span>
    <span class="p">]</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">quad_indptr</span><span class="p">[</span><span class="n">selected_offsets</span><span class="p">]</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">quad_indptr</span><span class="p">[</span><span class="n">selected_offsets</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">offset_index</span> <span class="o">=</span> <span class="n">offset</span>
    <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">):</span>
        <span class="n">spectrum_tof_indices</span><span class="p">[</span>
            <span class="n">offset_index</span><span class="p">:</span> <span class="n">offset_index</span> <span class="o">+</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">tof_indices</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span>
        <span class="n">spectrum_intensity_values</span><span class="p">[</span>
            <span class="n">offset_index</span><span class="p">:</span> <span class="n">offset_index</span> <span class="o">+</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">end</span><span class="p">]</span>
        <span class="n">offset_index</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">offset_end</span> <span class="o">=</span> <span class="n">spectrum_indptr</span><span class="p">[</span><span class="n">precursor_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">spectrum_tof_indices</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span> <span class="n">offset_end</span><span class="p">])</span>
    <span class="n">current_index</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">previous_tof_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">tof_index</span><span class="p">,</span> <span class="n">intensity</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">spectrum_tof_indices</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span> <span class="n">offset_end</span><span class="p">][</span><span class="n">order</span><span class="p">],</span>
        <span class="n">spectrum_intensity_values</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span> <span class="n">offset_end</span><span class="p">][</span><span class="n">order</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">tof_index</span> <span class="o">!=</span> <span class="n">previous_tof_index</span><span class="p">:</span>
            <span class="n">current_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">spectrum_tof_indices</span><span class="p">[</span><span class="n">current_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tof_index</span>
            <span class="n">spectrum_intensity_values</span><span class="p">[</span><span class="n">current_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensity</span>
            <span class="n">previous_tof_index</span> <span class="o">=</span> <span class="n">tof_index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spectrum_intensity_values</span><span class="p">[</span><span class="n">current_index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">intensity</span>
    <span class="n">spectrum_tof_indices</span><span class="p">[</span><span class="n">current_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="n">offset_end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">spectrum_intensity_values</span><span class="p">[</span><span class="n">current_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span> <span class="n">offset_end</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">spectrum_counts</span><span class="p">[</span><span class="n">precursor_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">offset</span></div>


<div class="viewcode-block" id="trim_spectra"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.trim_spectra">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">pjit</span>
<span class="k">def</span> <span class="nf">trim_spectra</span><span class="p">(</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">spectrum_tof_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spectrum_intensity_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">spectrum_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trimmed_spectrum_tof_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">trimmed_spectrum_intensity_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">new_spectrum_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Trim remaining bytes after merging of multiple pushes.</span>

<span class="sd">    IMPORTANT NOTE: This function is decorate with alphatims.utils.pjit.</span>
<span class="sd">    The first argument is thus expected to be provided as an iterable</span>
<span class="sd">    containing ints instead of a single int.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : int</span>
<span class="sd">        The push index whose intensity_values and tof_indices will be trimmed.</span>
<span class="sd">    spectrum_tof_indices : np.uint32[:]</span>
<span class="sd">        The original array containing tof indices.</span>
<span class="sd">    spectrum_intensity_values : np.uint32[:]</span>
<span class="sd">        The original array containing intensity values.</span>
<span class="sd">    spectrum_indptr : np.int64[:]</span>
<span class="sd">        An index pointer array defining the original spectrum boundaries.</span>
<span class="sd">    trimmed_spectrum_tof_indices : np.uint32[:]</span>
<span class="sd">        A buffer array to store new tof indices.</span>
<span class="sd">    trimmed_spectrum_intensity_values : np.uint32[:]</span>
<span class="sd">        A buffer array to store new intensity values.</span>
<span class="sd">    new_spectrum_indptr : np.int64[:]</span>
<span class="sd">        An index pointer array defining the trimmed spectrum boundaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">spectrum_indptr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">new_start</span> <span class="o">=</span> <span class="n">new_spectrum_indptr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">new_end</span> <span class="o">=</span> <span class="n">new_spectrum_indptr</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">trimmed_spectrum_tof_indices</span><span class="p">[</span><span class="n">new_start</span><span class="p">:</span> <span class="n">new_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectrum_tof_indices</span><span class="p">[</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">new_end</span> <span class="o">-</span> <span class="n">new_start</span>
    <span class="p">]</span>
    <span class="n">trimmed_spectrum_intensity_values</span><span class="p">[</span>
        <span class="n">new_start</span><span class="p">:</span> <span class="n">new_end</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">spectrum_intensity_values</span><span class="p">[</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">new_end</span> <span class="o">-</span> <span class="n">new_start</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="parse_keys"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.parse_keys">[docs]</a><span class="k">def</span> <span class="nf">parse_keys</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">TimsTOF</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Convert different keys to a key dict with defined types.</span>

<span class="sd">    NOTE: Negative slicing is not supported and all indiviudal keys</span>
<span class="sd">    are assumed to be sorted, disjunct and strictly increasing</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : alphatims.bruker.TimsTOF</span>
<span class="sd">        The TimsTOF objext for which to get slices.</span>
<span class="sd">    keys : tuple</span>
<span class="sd">        A tuple of at most 5 elemens, containing</span>
<span class="sd">        slices, ints, floats, Nones, and/or iterables.</span>
<span class="sd">        See `alphatims.bruker.convert_slice_key_to_int_array` and</span>
<span class="sd">        `alphatims.bruker.convert_slice_key_to_float_array` for more details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : dict</span>
<span class="sd">        The resulting dict always has the following items:</span>
<span class="sd">            - &quot;frame_indices&quot;: np.int64[:, :, :]</span>
<span class="sd">            - &quot;scan_indices&quot;: np.int64[:, :, :]</span>
<span class="sd">            - &quot;tof_indices&quot;: np.int64[:, :, :]</span>
<span class="sd">            - &quot;precursor_indices&quot;: np.int64[:, :, :]</span>
<span class="sd">            - &quot;quad_values&quot;: np.float64[:, :]</span>
<span class="sd">            - &quot;intensity_values&quot;: np.float64[:, :]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;frame_indices&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scan_indices&quot;</span><span class="p">,</span>
        <span class="s2">&quot;precursor_indices&quot;</span><span class="p">,</span>
        <span class="s2">&quot;tof_indices&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">dimension_slices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s2">&quot;LC-IMS-MSMS data can be sliced in maximum 5 dimensions. &quot;</span>
            <span class="s2">&quot;Integers are assumed to be indices, while &quot;</span>
            <span class="s2">&quot;floats are assumed as values. Intensity is always casted &quot;</span>
            <span class="s2">&quot;to integer values, regardless of input type.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">new_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dimension_translations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;frame_indices&quot;</span><span class="p">:</span> <span class="s2">&quot;rt_values&quot;</span><span class="p">,</span>
            <span class="s2">&quot;scan_indices&quot;</span><span class="p">:</span> <span class="s2">&quot;mobility_values&quot;</span><span class="p">,</span>
            <span class="s2">&quot;precursor_indices&quot;</span><span class="p">:</span> <span class="s2">&quot;quad_mz_values&quot;</span><span class="p">,</span>
            <span class="s2">&quot;tof_indices&quot;</span><span class="p">:</span> <span class="s2">&quot;mz_values&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">dimension_translations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">new_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">indices</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">new_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">values</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="s2">&quot;intensity_values&quot;</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">new_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;intensity_values&quot;</span><span class="p">])</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">new_keys</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dimension</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dimension_slices</span><span class="p">[</span>
                <span class="n">dimension</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">convert_slice_key_to_int_array</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
                <span class="n">dimension</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">PrecursorFloatError</span><span class="p">:</span>
            <span class="n">dimension_slices</span><span class="p">[</span>
                <span class="s2">&quot;precursor_indices&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">convert_slice_key_to_int_array</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
                <span class="s2">&quot;precursor_indices&quot;</span>
            <span class="p">)</span>
            <span class="n">dimension_slices</span><span class="p">[</span>
                <span class="s2">&quot;quad_values&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">convert_slice_key_to_float_array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">dimension_slices</span><span class="p">[</span>
        <span class="s2">&quot;intensity_values&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">convert_slice_key_to_float_array</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;quad_values&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dimension_slices</span><span class="p">:</span>
        <span class="n">dimension_slices</span><span class="p">[</span><span class="s2">&quot;quad_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">dimension_slices</span></div>


<div class="viewcode-block" id="convert_slice_key_to_float_array"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.convert_slice_key_to_float_array">[docs]</a><span class="k">def</span> <span class="nf">convert_slice_key_to_float_array</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">TimsTOF</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a key of a data object to a slice float array.</span>

<span class="sd">    NOTE: This function should only be used for QUAD or DETECTOR dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : alphatims.bruker.TimsTOF</span>
<span class="sd">        The TimsTOF objext for which to get slices.</span>
<span class="sd">    key : slice, int, float, None, iterable</span>
<span class="sd">        The key that needs to be converted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : np.float64[:, :]</span>
<span class="sd">        Each row represent a a (start, stop) slice.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When the key is an np.ndarray with more than 2 columns.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span></div>


<div class="viewcode-block" id="convert_slice_key_to_int_array"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.convert_slice_key_to_int_array">[docs]</a><span class="k">def</span> <span class="nf">convert_slice_key_to_int_array</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">TimsTOF</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a key of a data dimension to a slice integer array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : alphatims.bruker.TimsTOF</span>
<span class="sd">        The TimsTOF objext for which to get slices.</span>
<span class="sd">    key : slice, int, float, None, iterable</span>
<span class="sd">        The key that needs to be converted.</span>
<span class="sd">    dimension : str</span>
<span class="sd">        The dimension for which the key needs to be retrieved</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : np.int64[:, :, :]</span>
<span class="sd">        Each row represent a a (start, stop, step) slice.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        When the key contains elements other than int or float.</span>
<span class="sd">    PrecursorFloatError</span>
<span class="sd">        When trying to convert a quad float to precursor index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">iter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">start</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">convert_to_indices</span><span class="p">(</span>
                    <span class="n">start</span><span class="p">,</span>
                    <span class="n">return_type</span><span class="o">=</span><span class="n">dimension</span>
                <span class="p">)</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">convert_to_indices</span><span class="p">(</span>
                    <span class="n">stop</span><span class="p">,</span>
                    <span class="n">return_type</span><span class="o">=</span><span class="n">dimension</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">==</span> <span class="s2">&quot;scan_indices&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">):</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span><span class="p">,</span> <span class="n">start</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">convert_to_indices</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">==</span> <span class="s2">&quot;scan_indices&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">key</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">convert_to_indices</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="n">dimension</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">size</span><span class="p">)])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span></div>


<div class="viewcode-block" id="valid_quad_mz_values"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.valid_quad_mz_values">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">njit</span>
<span class="k">def</span> <span class="nf">valid_quad_mz_values</span><span class="p">(</span>
    <span class="n">low_mz_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">high_mz_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">quad_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Check if the low and high quad mz values are included in the slices.</span>

<span class="sd">    NOTE: Just a part of the quad range needs to overlap with a part</span>
<span class="sd">    of a single slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    low_mz_value : float</span>
<span class="sd">        The lower mz value of the current quad selection.</span>
<span class="sd">    high_mz_value : float</span>
<span class="sd">        The upper mz value of the current quad selection.</span>
<span class="sd">    quad_slices : np.float64[:, :]</span>
<span class="sd">        Each row of the array is assumed to be (lower_mz, upper_mz) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(quad_slices.ravel()) &gt;= 0) = True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : bool</span>
<span class="sd">        True if some part of the quad overlaps with some part of some slice.</span>
<span class="sd">        False if there is no overlap in the range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slice_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
        <span class="n">quad_slices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
        <span class="n">high_mz_value</span><span class="p">,</span>
        <span class="s2">&quot;right&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">low_mz_value</span> <span class="o">&lt;=</span> <span class="n">quad_slices</span><span class="p">[</span><span class="n">slice_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="valid_precursor_index"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.valid_precursor_index">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">njit</span>
<span class="k">def</span> <span class="nf">valid_precursor_index</span><span class="p">(</span>
    <span class="n">precursor_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">precursor_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Check if a precursor index is included in the slices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    precursor_index : int</span>
<span class="sd">        The precursor index to validate.</span>
<span class="sd">    precursor_slices : np.int64[:, :, :]</span>
<span class="sd">        Each row of the array is assumed to be a (start, stop, step) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(precursor_slices[:, :2].ravel()) &gt;= 0) = True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : bool</span>
<span class="sd">        True if the precursor index is present in any of the slices.</span>
<span class="sd">        False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slice_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
        <span class="n">precursor_slices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
        <span class="n">precursor_index</span><span class="p">,</span>
        <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">precursor_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
        <span class="n">precursor_slices</span><span class="p">[</span><span class="n">slice_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">precursor_slices</span><span class="p">[</span><span class="n">slice_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">precursor_slices</span><span class="p">[</span><span class="n">slice_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="filter_indices"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.filter_indices">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">njit</span>
<span class="k">def</span> <span class="nf">filter_indices</span><span class="p">(</span>
    <span class="n">frame_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">scan_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">precursor_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tof_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">quad_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">intensity_slices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">frame_max_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">scan_max_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">push_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">precursor_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">quad_mz_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">quad_indptr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tof_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">intensities</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Filter raw indices by slices from all dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame_slices : np.int64[:, :, :]</span>
<span class="sd">        Each row of the array is assumed to be a (start, stop, step) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(frame_slices[:, :2].ravel()) &gt;= 0) = True).</span>
<span class="sd">    scan_slices : np.int64[:, :, :]</span>
<span class="sd">        Each row of the array is assumed to be a (start, stop, step) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(scan_slices[:, :2].ravel()) &gt;= 0) = True).</span>
<span class="sd">    precursor_slices : np.int64[:, :, :]</span>
<span class="sd">        Each row of the array is assumed to be a (start, stop, step) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(precursor_slices[:, :2].ravel()) &gt;= 0) = True).</span>
<span class="sd">    tof_slices : np.int64[:, :, :]</span>
<span class="sd">        Each row of the array is assumed to be a (start, stop, step) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(tof_slices[:, :2].ravel()) &gt;= 0) = True).</span>
<span class="sd">    quad_slices : np.float64[:, :]</span>
<span class="sd">        Each row of the array is assumed to be (lower_mz, upper_mz) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(quad_slices.ravel()) &gt;= 0) = True).</span>
<span class="sd">    intensity_slices : np.float64[:, :]</span>
<span class="sd">        Each row of the array is assumed to be (lower_mz, upper_mz) tuple.</span>
<span class="sd">        This array is assumed to be sorted, disjunct and strictly increasing</span>
<span class="sd">        (i.e. np.all(np.diff(intensity_slices.ravel()) &gt;= 0) = True).</span>
<span class="sd">    frame_max_index : int</span>
<span class="sd">        The maximum frame index of a TimsTOF object.</span>
<span class="sd">    scan_max_index : int</span>
<span class="sd">        The maximum scan index of a TimsTOF object.</span>
<span class="sd">    push_indptr : np.int64[:]</span>
<span class="sd">        The self.push_indptr array of a TimsTOF object.</span>
<span class="sd">    precursor_indices : np.int64[:]</span>
<span class="sd">        The self.precursor_indices array of a TimsTOF object.</span>
<span class="sd">    quad_mz_values : np.float64[:, :]</span>
<span class="sd">        The self.quad_mz_values array of a TimsTOF object.</span>
<span class="sd">    quad_indptr : np.int64[:]</span>
<span class="sd">        The self.quad_indptr array of a TimsTOF object.</span>
<span class="sd">    tof_indices : np.uint32[:]</span>
<span class="sd">        The self.tof_indices array of a TimsTOF object.</span>
<span class="sd">    intensities : np.uint16[:]</span>
<span class="sd">        The self.intensity_values array of a TimsTOF object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : np.int64[:]</span>
<span class="sd">        The raw indices that satisfy all the slices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">quad_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">new_quad_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">quad_end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">is_valid_quad_index</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">starts</span> <span class="o">=</span> <span class="n">push_indptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">frame_max_index</span><span class="p">,</span>
        <span class="n">scan_max_index</span>
    <span class="p">)</span>
    <span class="n">ends</span> <span class="o">=</span> <span class="n">push_indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">frame_max_index</span><span class="p">,</span>
        <span class="n">scan_max_index</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">frame_start</span><span class="p">,</span> <span class="n">frame_stop</span><span class="p">,</span> <span class="n">frame_step</span> <span class="ow">in</span> <span class="n">frame_slices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">frame_start_slice</span><span class="p">,</span> <span class="n">frame_end_slice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">starts</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">frame_start</span><span class="p">,</span> <span class="n">frame_stop</span><span class="p">,</span> <span class="n">frame_step</span><span class="p">)],</span>
            <span class="n">ends</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">frame_start</span><span class="p">,</span> <span class="n">frame_stop</span><span class="p">,</span> <span class="n">frame_step</span><span class="p">)]</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">scan_start</span><span class="p">,</span> <span class="n">scan_stop</span><span class="p">,</span> <span class="n">scan_step</span> <span class="ow">in</span> <span class="n">scan_slices</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sparse_start</span><span class="p">,</span> <span class="n">sparse_end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">frame_start_slice</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">scan_start</span><span class="p">,</span> <span class="n">scan_stop</span><span class="p">,</span> <span class="n">scan_step</span><span class="p">)],</span>
                    <span class="n">frame_end_slice</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">scan_start</span><span class="p">,</span> <span class="n">scan_stop</span><span class="p">,</span> <span class="n">scan_step</span><span class="p">)]</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">sparse_start</span> <span class="o">==</span> <span class="n">sparse_end</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">while</span> <span class="n">quad_end</span> <span class="o">&lt;</span> <span class="n">sparse_end</span><span class="p">:</span>
                        <span class="n">new_quad_index</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">quad_end</span> <span class="o">=</span> <span class="n">quad_indptr</span><span class="p">[</span><span class="n">new_quad_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">quad_index</span> <span class="o">!=</span> <span class="n">new_quad_index</span><span class="p">:</span>
                        <span class="n">quad_index</span> <span class="o">=</span> <span class="n">new_quad_index</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid_quad_mz_values</span><span class="p">(</span>
                            <span class="n">quad_mz_values</span><span class="p">[</span><span class="n">quad_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="n">quad_mz_values</span><span class="p">[</span><span class="n">quad_index</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">quad_slices</span>
                        <span class="p">):</span>
                            <span class="n">is_valid_quad_index</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="n">valid_precursor_index</span><span class="p">(</span>
                            <span class="n">precursor_indices</span><span class="p">[</span><span class="n">quad_index</span><span class="p">],</span>
                            <span class="n">precursor_slices</span><span class="p">,</span>
                        <span class="p">):</span>
                            <span class="n">is_valid_quad_index</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">is_valid_quad_index</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_valid_quad_index</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">sparse_start</span>
                    <span class="k">for</span> <span class="n">tof_start</span><span class="p">,</span> <span class="n">tof_stop</span><span class="p">,</span> <span class="n">tof_step</span> <span class="ow">in</span> <span class="n">tof_slices</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                            <span class="n">tof_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span> <span class="n">sparse_end</span><span class="p">],</span>
                            <span class="n">tof_start</span>
                        <span class="p">)</span>
                        <span class="n">tof_value</span> <span class="o">=</span> <span class="n">tof_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="k">while</span> <span class="p">(</span><span class="n">tof_value</span> <span class="o">&lt;</span> <span class="n">tof_stop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">sparse_end</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">tof_value</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                                <span class="n">tof_start</span><span class="p">,</span>
                                <span class="n">tof_stop</span><span class="p">,</span>
                                <span class="n">tof_step</span>
                            <span class="p">):</span>
                                <span class="n">intensity</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                                <span class="k">for</span> <span class="p">(</span>
                                    <span class="n">low_intensity</span><span class="p">,</span>
                                    <span class="n">high_intensity</span>
                                <span class="p">)</span> <span class="ow">in</span> <span class="n">intensity_slices</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="n">low_intensity</span> <span class="o">&lt;=</span> <span class="n">intensity</span><span class="p">):</span>
                                        <span class="k">if</span> <span class="p">(</span><span class="n">intensity</span> <span class="o">&lt;=</span> <span class="n">high_intensity</span><span class="p">):</span>
                                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                                            <span class="k">break</span>
                            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="n">tof_value</span> <span class="o">=</span> <span class="n">tof_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<span class="c1"># TODO: Overhead of using multiple threads is slower</span>
<div class="viewcode-block" id="add_intensity_to_bin"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.add_intensity_to_bin">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">pjit</span><span class="p">(</span><span class="n">thread_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add_intensity_to_bin</span><span class="p">(</span>
    <span class="n">query_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">intensities</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">parsed_indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">intensity_bins</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add the intensity of a query to the appropriate bin.</span>

<span class="sd">    IMPORTANT NOTE: This function is decorate with alphatims.utils.pjit.</span>
<span class="sd">    The first argument is thus expected to be provided as an iterable</span>
<span class="sd">    containing ints instead of a single int.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    query_index : int</span>
<span class="sd">        The query whose intensity needs to be binned</span>
<span class="sd">        The first argument is thus expected to be provided as an iterable</span>
<span class="sd">        containing ints instead of a single int.</span>
<span class="sd">    intensities : np.float64[:]</span>
<span class="sd">        An array with intensities that need to be binned.</span>
<span class="sd">    parsed_indices : np.int64[:], np.int64[:, :]</span>
<span class="sd">        Description of parameter `parsed_indices`.</span>
<span class="sd">    intensity_bins : np.float64[:]</span>
<span class="sd">        A buffer with intensity bins to which the current query will be added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">intensity</span> <span class="o">=</span> <span class="n">intensities</span><span class="p">[</span><span class="n">query_index</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">intensity_bins</span><span class="p">[</span><span class="n">parsed_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">query_index</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">intensity</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">parsed_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">intensity_bins</span><span class="p">[</span>
            <span class="n">parsed_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">query_index</span><span class="p">],</span>
            <span class="n">parsed_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">query_index</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">+=</span> <span class="n">intensity</span></div>


<div class="viewcode-block" id="indptr_lookup"><a class="viewcode-back" href="../../alphatims.bruker.html#alphatims.bruker.indptr_lookup">[docs]</a><span class="nd">@alphatims</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">njit</span>
<span class="k">def</span> <span class="nf">indptr_lookup</span><span class="p">(</span>
    <span class="n">targets</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">queries</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">momentum_amplifier</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find the indices of queries in targets.</span>

<span class="sd">    This function is equivalent to</span>
<span class="sd">    &quot;np.searchsorted(targets, queries, &quot;right&quot;) - 1&quot;.</span>
<span class="sd">    By utilizing the fact that queries are also sorted,</span>
<span class="sd">    it is significantly faster though.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    targets : np.int64[:]</span>
<span class="sd">        A sorted list of index pointers where queries needs to be looked up.</span>
<span class="sd">    queries : np.int64[:]</span>
<span class="sd">        A sorted list of queries whose index pointers needs to be looked up.</span>
<span class="sd">    momentum_amplifier : int</span>
<span class="sd">        Factor to add momentum to linear searching, attempting to quickly</span>
<span class="sd">        discard empty range without hits.</span>
<span class="sd">        Invreasing it can speed up searching of queries if they are sparsely</span>
<span class="sd">        spread out in targets.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : np.int64[:]</span>
<span class="sd">        The indices of queries in targets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span>
    <span class="n">target_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">no_target_overflow</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">query_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">queries</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">no_target_overflow</span><span class="p">:</span>
            <span class="n">momentum</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">targets</span><span class="p">[</span><span class="n">target_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">query_index</span><span class="p">:</span>
                <span class="n">target_index</span> <span class="o">+=</span> <span class="n">momentum</span>
                <span class="k">if</span> <span class="n">target_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">targets</span><span class="p">):</span>
                    <span class="k">break</span>
                <span class="n">momentum</span> <span class="o">*=</span> <span class="n">momentum_amplifier</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">momentum</span> <span class="o">&lt;=</span> <span class="n">momentum_amplifier</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_index</span> <span class="o">-=</span> <span class="n">momentum</span> <span class="o">//</span> <span class="n">momentum_amplifier</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="n">momentum</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">no_target_overflow</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">target_index</span> <span class="o">-=</span> <span class="n">momentum</span>
        <span class="n">hits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_index</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">hits</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Mann Labs, MPIB.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>